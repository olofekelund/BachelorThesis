/*
 * generated by Xtext
 */
package org.language.generator


import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import java.util.HashMap
import java.util.ArrayList
import org.language.reqLanguage.Model
import org.language.reqLanguage.Requirement
import org.language.generator.Tree
import org.language.generator.Sequence
import org.language.reqLanguage.MainComposition
import org.language.reqLanguage.MainFunction
import org.language.reqLanguage.System
import org.language.reqLanguage.Actor
import org.language.reqLanguage.Prefix
import org.language.reqLanguage.PrefixState
import org.language.reqLanguage.PrefixCondition
import org.language.reqLanguage.PrefixEvent
import org.language.reqLanguage.State
import org.language.reqLanguage.ParameterState
import org.language.reqLanguage.Time
import org.language.reqLanguage.Parameter
import org.language.reqLanguage.ParamEvent
import org.language.reqLanguage.ActorEvent
import org.language.reqLanguage.StateEvent
import org.language.reqLanguage.Value
import org.language.reqLanguage.User
import org.language.reqLanguage.MainAttributes
import org.language.reqLanguage.MainFunctions


class ReqLanguageGenerator implements IGenerator {
	
	HashMap<String, Integer> entityIds = new HashMap()
	int idCounter = 0
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for (model : resource.allContents.toIterable.filter(Model)) {
			val Tree<String> classTree = createClassTree(model)
			val ArrayList<Sequence> sequenceArray = createSequenceArray(model)
			
			fsa.generateFile("system.xmi", classTree.createUMLModel())
			fsa.generateFile("classdiagram.reqld", classTree.createClassDiagram())
			fsa.generateFile("sequencediagram.reqld", sequenceArray.createSequenceDiagram())
		}
	}

	def int getXmiId(String name) {
		if(entityIds.containsKey(name)) return entityIds.get(name)
		else {
			entityIds.put(name, idCounter++)
			return idCounter - 1
		}
	}

	def Tree<String> createClassTree(Model m) {
		val Tree<String> tree = new Tree
		tree.add("root")
		for(requirement: m.requirements) {
			if (requirement.mainRequirement instanceof MainComposition) {
				addRequirementToTree(requirement.mainRequirement as MainComposition, tree)
			} else if (requirement.mainRequirement instanceof MainAttributes) {
				addRequirementAttributeToTree(requirement.mainRequirement as MainAttributes, tree)
			} else if (requirement.mainRequirement instanceof MainFunctions) {
				addRequirementFunctionToTree(requirement.mainRequirement as MainFunctions, tree)
			}
		}
		return tree
	}
	
	// Attributes
	def addRequirementAttributeToTree(MainAttributes main, Tree<String> tree) {
		println("addAttribute")
		val Tree<String> node = tree.find(main.system.name)
		
		if (node != null) {
			println("addAttribute2")
			for(attribute: main.attributeList)  {
				node.addAttribute(new StringTuple(attribute.type, attribute.name))
			}
		}
	}
	
	//Functions
	def addRequirementFunctionToTree(MainFunctions main, Tree<String> tree) {
		val Tree<String> node = tree.find(main.system.name)
		
		if (node != null) {
			for(function: main.functionList)  {
				println(function.name)
				node.addFunction(new StringTuple(function.type, function.name))
			}
		}
	}
	
	// Composition
	def addRequirementToTree(MainComposition main, Tree<String> tree) {
		tree.add(main.system.name)
		
		for(ss: main.subsystemList) {
			tree.find(main.system.name).add(ss.name)
		}
	}
	
	def String getActor(MainFunction main) {
		var String actor = ""
		if (main.system instanceof System) {
			val System s = main.system as System
			
			actor = s.name
		} else if(main.system instanceof Actor) {
			val Actor a = main.system as Actor
			
			actor = a.name
		} else {			
			actor = "user"
		}
		
		return actor
	}

	def String getSubject(MainFunction main) {
		var String subject = null 
		
		if (main.function.subject instanceof System) {
			val System system = main.function.subject as System
			
			subject = system.name 
		} else if (main.function.subject instanceof Actor) {
			val Actor actor = main.function.subject as Actor
			
			subject = actor.name
		} else if (main.function.subject instanceof Parameter) {
			val Parameter parameter = main.function.subject as Parameter
			
			subject = parameter.name
		}
		
		return subject
	}

	def String getParameter(MainFunction main) {
		var String parameter = null 
		
		if (main.function.parameter != null ) {
			val Parameter param = main.function.parameter as Parameter
			
			parameter = param.name
		}
		
		return parameter
	}

	def String getAction(MainFunction main) {		
		return main.function.name
	}
	
	// Sequence diagram methods
	def ArrayList<Sequence> createSequenceArray(Model m) {
		val ArrayList<Sequence> array = new ArrayList
		for(requirement: m.requirements) {
			if (requirement.mainRequirement instanceof MainFunction) {
				val Prefix prefix = requirement.prefix as Prefix
				addRequirementToSequenceArray(prefix, requirement, array)
			}
		}
		
		return array
	}
	
	// Main function for processing functional requirements
	def ArrayList<Sequence> addRequirementToSequenceArray(Prefix prefix, Requirement requirement, ArrayList<Sequence> array) {
		val MainFunction main = requirement.mainRequirement as MainFunction
		val String prefixString = processPrefix(prefix)
		val String actor = getActor(main)
		val String subject = getSubject(main)
		val String parameter = getParameter(main)
		val String action = getAction(main)
				
		if (actor != null && subject != null && action != null) {
			if (main.function.value != null) {
				array.add(new Sequence(actor, subject, action, parameter, main.function.value.value, prefixString))
			} else {
				array.add(new Sequence(actor, subject, action, parameter, prefixString))
			}
		} else println("addRequirementToSequenceArray: didn't add sequence, something's null")
		
		return array
	}

	def processPrefix(Prefix prefix) {
		var String out = ""
		
		if (prefix != null) {
			if(prefix.leftOperand instanceof PrefixState) {
				out += processPrefixState(prefix.leftOperand as PrefixState)
			} else if(prefix.leftOperand instanceof PrefixCondition) {
				out += processPrefixCondition(prefix.leftOperand as PrefixCondition)
			} else if(prefix.leftOperand instanceof PrefixEvent) {
				out += processPrefixEvent(prefix.leftOperand as PrefixEvent)
			}
			
			for (p: prefix.prefixList) {
				if (p.operator == "and") out += " && "
				else if (p.operator == "or") out += " || "
				
				if(p.prefixRightOperand instanceof PrefixState) {
					out += processPrefixState(p.prefixRightOperand as PrefixState)
				} else if(p.prefixRightOperand instanceof PrefixCondition) {
					out += processPrefixCondition(p.prefixRightOperand as PrefixCondition)
				} else if(p.prefixRightOperand instanceof PrefixEvent) {
					out += processPrefixEvent(p.prefixRightOperand as PrefixEvent)
				}	
			}
		}
		
		return out
	}
	
	def processPrefixState(PrefixState p) {
		var String out = ""
		println("processPrefixState: " + p.prefixFixedSyntax)
		out += p.prefixFixedSyntax
		
		if (p.stateExpression instanceof State) {
			val State s = p.stateExpression as State
			println("processPrefixStateIf: " + s.name)
			out += " " + s.name 
		} else if (p.stateExpression instanceof ParameterState) {
			val ParameterState s = p.stateExpression as ParameterState
			println("processPrefixStateElseIf: " + s.parameter.name)
			out += " " + s.parameter.name
			
			if (s.parameter_value instanceof Value) {
				var Value value = s.parameter_value as Value
				
				out += " == " + value.value				
			} else if (s.parameter_value instanceof State) {
				var State state = s.parameter_value as State
				
				out += " == " + state.name
			} else out += "error"
		}
	}
	
	def processPrefixCondition(PrefixCondition p) {
		var String out = ""
		println("Condition" + p.prefixFixedSyntax)
		out += p.prefixFixedSyntax
		
		if (p.parameter instanceof Time) {
			val Time t = p.parameter as Time
			out += " " + t.value + t.timeUnit 
		} else if (p.parameter instanceof Parameter) {
			val Parameter param = p.parameter as Parameter
			out += " " + param.name
		}
		
		switch p.operator.operator { 
			case "less_than": out += " < "
			case "equal_to": out += " == "
			case "greater_than": out += " > "
			case "not_equal_to": out += " != "
			case "greater_than_or_equal_to": out += " >= "
			case "less_than_or_equal_to": out += " <= "
		}
		if (p.value != null) out += p.value.value
		
		if (p.time != null) {
			out += p.time.time.value + " " + p.time.time.timeUnit
		}
		println("ConditionReturn: " + out)
		return out
	}
	
	def processPrefixEvent(PrefixEvent p) {
		var String out = ""
		
		out += p.prefixFixedSyntax
		
		// ParamEvent
		if (p.event_expression instanceof ParamEvent) {
			val ParamEvent event = p.event_expression as ParamEvent
			
			if (event.parameter instanceof Parameter) {
				val Parameter parameter = event.parameter as Parameter
				
				out += " " + parameter.name
			} else if (event.parameter instanceof Time) {
				val Time time = event.parameter as Time
				
				out += " " time.value + time.timeUnit
			}
			val Value value = event.value as Value

			out += " " + event.action + " " + value.value
			
		// ActorEvent
		} else if (p.event_expression instanceof ActorEvent) {
			val ActorEvent event = p.event_expression as ActorEvent
			
			if (event.actor instanceof System) {
				val System actor = event.actor as System
				
				out += " " + actor.name				
			} else if (event.actor instanceof User) {
				val User actor = event.actor as User
				
				out += " " + actor.name
			}
			val Parameter parameter = event.entity as Parameter
			
			out += " " + event.action + " " parameter.name
			
		// StateEvent
		} else if (p.event_expression instanceof StateEvent) {
			val StateEvent event = p.event_expression as StateEvent
			out += " " + event.system.name + " starts in state: " event.state.name 	
		}
		
		return out
	}


// Generate plantUML class diagram file
	def createClassDiagram(Tree<String> tree) '''
	@startuml
	«tree.classMain»
	@enduml
	'''
	  	
  	def String classMain(Tree<String> tree) '''
  	«IF (tree.attributes.size > 0)» 
	class «tree.data» {
  		«FOR attribute:tree.attributes»
		«attribute.type» «attribute.name»
		«ENDFOR»
		«FOR function: tree.functions»
		«function.type» «function.name»()
		«ENDFOR»
	}
	«ENDIF»
	«IF (tree.children.size > 0) »
	«FOR child: tree.children»
	«IF (tree.data != "root")»
	«tree.data» *-- «child.data»
	«ENDIF»
	«if (child.children != null) child.classMain»
	«ENDFOR»
	«ENDIF»
	'''
	
	def createSequenceDiagram(ArrayList<Sequence> array) '''
	@startuml
	«array.sequenceMain»
	@enduml
	'''
	
	def String sequenceMain(ArrayList<Sequence> array) '''
  	«IF (array.size > 0) »
		«FOR sequence:array»
	  		«sequence.actor1» -> «sequence.actor2»: «IF (!sequence.condition.equals(""))»«sequence.condition»«ENDIF»: «sequence.action»(«IF (sequence.parameter != null)»«sequence.parameter»: «ENDIF»«IF (sequence.hasValue)»«sequence.value»«ENDIF»)
	  	«ENDFOR»
	«ENDIF»
  	'''
	
// «»
  	def createUMLModel(Tree<String> tree)
'''<?xml version="1.0" encoding="UTF-8"?>
<uml:Model xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML" xmi:id="__test_xmi" name="Model">
	<packageImport xmi:type="uml:PackageImport" xmi:id="__test_xmi">
		<importedPackage xmi:type="uml:Model" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#_0"/>
	</packageImport>
	«FOR child:tree.children»
	«child.processTreeXMI»
	«ENDFOR»
</uml:Model>
  	'''
  	
  	def String processTreeXMI(Tree<String> tree)
'''
«var boolean empty = (tree.attributes.empty && tree.functions.empty)»
<packagedElement xmi:type="uml:Class" xmi:id="_«getXmiId(tree.data)»" name="«tree.data»"«IF(empty)»/«ENDIF»>
	«FOR attribute:tree.attributes»
		<ownedAttribute xmi:type="uml:Property" xmi:id="_att«getXmiId(attribute.type + attribute.name)»" name="«attribute.name»"/>
	«ENDFOR»
	«FOR function:tree.functions»
		<ownedOperation xmi:type="uml:Operation" xmi:id="_op«getXmiId(function.type + function.name)»" name="«function.name»"/>
	«ENDFOR»
«IF(!empty)»</packagedElement>«ENDIF»
«FOR child:tree.children»
«child.processTreeXMI»
«ENDFOR»
«FOR child:tree.children»
<packagedElement xmi:type="uml:Dependency" xmi:id="_dep«getXmiId(child.data)»" client="_«getXmiId(child.data)»" supplier="_«getXmiId(tree.data)»"/>
«ENDFOR»
'''
}
